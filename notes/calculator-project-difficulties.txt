Es ist absolut normal, dass ein scheinbar â€žkleinesâ€œ Projekt â€“ wie ein Taschenrechner â€“ unverhÃ¤ltnismÃ¤ÃŸig schwer wird. Viele Entwickler kennen genau dieses PhÃ¤nomen. Ich erklÃ¤re dir, warum gerade ein Taschenrechner oft frustrierend komplex wird.


â­ Warum ein Taschenrechner viel schwerer ist als man denkt
1. Du baust einen Parser â€“ ohne es zu merken


Ein Taschenrechner wirkt simpel: Knopf drÃ¼cken â†’ Zahl â†’ Operator â†’ Zahl â†’ Ergebnis.


Aber sobald du ein bisschen mehr willst (mehrere Operationen, Komma, Vorzeichen, LÃ¶schen, Prozent, Klammern, Tastaturbedienung etc.), programmierst du plÃ¶tzlich:

Tokenisierung

Operator-PrioritÃ¤ten

Zustandsautomaten

Fehlerbehandlung

Validierung ungewÃ¶hnlicher Eingaben

UI-Logik

Edge-Case-HÃ¶lle ( ".", "000", "++", "1/0", "=" mehrfach, etc.)

Das ist Mini-Compilerbau. Das ist schwer â€“ selbst fÃ¼r Profis.

Taschenrechner haben Ã¼berraschend viele ZustÃ¤nde:

| Phase               | Beispiel        |
| ------------------- | --------------- |
| Eingabe leer        | ""              |
| Eingabe Zahl        | "12"            |
| Operator gewÃ¤hlt    | "â€”"             |
| Zwischenresultat    | "53"            |
| Fehlerzustand       | "NaN"           |
| Nach-gleich Zustand | "12=", was nun? |

Diese ZustÃ¤nde klar zu modellieren ist schwieriger als man denkt.






1. Baue zuerst einen â€žSingle Operation Calculatorâ€œ
Zahl A  op  Zahl B  =  Ergebnis

2. Mache eine echte Zustandsmaschine
state = "start" | "numA" | "operator" | "numB" | "result"

FÃ¼r jeden Ãœbergang definierst du:
Wenn state = "numA" und Taste = operator â†’ state = "operator"


â­ State Machine fÃ¼r einen Basis-Taschenrechner

Diese Version deckt folgende Funktionen ab:

Eingabe erster Zahl

Auswahl Operator

Eingabe zweiter Zahl

Berechnung mit "="

Fortsetzung einer Rechnung nach "="

â€žClearâ€œ (C)

(Erweiterungen fÃ¼r Komma, Vorzeichen, Backspace usw. lassen sich danach problemlos einbauen.)


ðŸ”¹ 1. Die fÃ¼nf HauptzustÃ¤nde
START      â€“ Noch keine Eingabe
NUM_A      â€“ Erste Zahl wird eingegeben
OPERATOR   â€“ Operator wurde gewÃ¤hlt
NUM_B      â€“ Zweite Zahl wird eingegeben
RESULT     â€“ Ergebnis wurde berechnet


ðŸ”¹ 2. Die mÃ¶glichen Eingabetypen
DIGIT       â†’ 0â€“9
DOT         â†’ .
OP          â†’ + - * /
EQUAL       â†’ =
CLEAR       â†’ C

ðŸ”¹ 3. State Machine Diagramm (textuell)
START
  |--DIGIT--> NUM_A

NUM_A
  |--DIGIT--> NUM_A
  |--DOT----> NUM_A   (Komma bei Bedarf)
  |--OP-----> OPERATOR
  |--CLEAR--> START

OPERATOR
  |--DIGIT--> NUM_B
  |--DOT----> NUM_B
  |--OP-----> OPERATOR  (Operator wechseln)
  |--CLEAR--> START

NUM_B
  |--DIGIT--> NUM_B
  |--DOT----> NUM_B
  |--EQUAL--> RESULT
  |--OP-----> RESULT â†’ OPERATOR  (Kettenrechnung)
  |--CLEAR--> START

RESULT
  |--DIGIT--> NUM_A  (neue Rechnung starten)
  |--OP-----> OPERATOR  (weiterrechnen mit Ergebnis)
  |--CLEAR--> START
  |--EQUAL--> RESULT  (nichts tun)
